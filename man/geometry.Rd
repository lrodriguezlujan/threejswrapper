% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geometries.R
\name{geoThreeJS}
\alias{cylinder}
\alias{cylinderGeometry}
\alias{geoThreeJS}
\alias{geometry}
\alias{is.geoThreeJS}
\alias{mesh}
\alias{meshGeometry}
\alias{parametric}
\alias{parametricGeometry}
\alias{sphere}
\alias{sphereGeometry}
\alias{toJSONList.geoThreeJS}
\alias{torus}
\alias{torusGeometry}
\title{ThreeJS Geometries}
\usage{
geoThreeJS(builder, materialIndex = 0, vertex.color.fun = NULL,
  face.color.fun = NULL, face.material.fun = NULL, compute.bbox = F,
  compute.fn = F, compute.vn = F, remove.dupvn = T, color.extra = NULL)

is.geoThreeJS(obj)

\method{toJSONList}{geoThreeJS}(obj)

meshGeometry(vertices, faces, ...)

sphereGeometry(radius, position = c(0, 0, 0), rotation = c(0, 0, 0),
  wsegs = 8, hsegs = 6, phiStart = 0, phiLen = 2 * pi, thetaStart = 0,
  thetaLen = pi, ...)

cylinderGeometry(initPoint = c(0, -50, 0), endPoint = NULL, height = 100,
  orientation = c(0, 1, 0), initRad = 20, endRad = 20, rSegs = 20,
  hSegs = 20, openEnded = F, thetaStart = 0, thetaLen = 2 * pi, ...)

parametricGeometry(fun, translation = c(0, 0, 0), rotation = c(0, 0, 0),
  scale = c(1, 1, 1), nx = 100, ny = 100, ...)

torusGeometry(inner = 8, outer = 12, rsegs = 16, lsegs = 50, angle = 2
  * pi, position = c(0, 0, 0), rotation = c(0, 0, 0), ...)
}
\arguments{
\item{builder}{Javascript function that builds the geometry}

\item{materialIndex}{Material index to apply to the geometry faces.}

\item{vertex.color.fun}{Javascript function \code{f( vertex , geo, index, extra )} that computes the color of each vertex. Should return a RGB color.}

\item{face.color.fun}{Javascript function \code{f( face, vertex a, vertex b, vertex c , geo, index, extra )} that computes the color of each face. Should return a RGB color.}

\item{face.material.fun}{Javascript function \code{f(face, vertex a, vertex b, vertex c , geo, index, extra )} that computes the material of each face. Should return a integer.}

\item{compute.bbox}{If true, \code{.computeBoundingBox()} function is called on the geometry.}

\item{compute.fn}{If true, \code{.computeFaceNormals()} function is called on the geometry. Required for light effects!}

\item{compute.vn}{If true, \code{.computeFaceNormals()} function is called on the geometry.}

\item{remove.dupvn}{If true, \code{.mergeVertices()} function is called on the geometry and duplicated vertices are merged.}

\item{color.extra}{Extra parameter for color functions}

\item{vertices}{A numeric matrix or dataframe where the first three columns are the cartesian coordiantes of the vertices. The fourth could be used as the vertex color.}

\item{faces}{A numeric matrix or dataframe where the first three columns are the vertex index of each triangular face of the mesh.}

\item{radius}{Sphere radius}

\item{position}{Sphere center coordinates}

\item{rotation}{Sphere x,y,z rotation}

\item{wsegs}{Number of horizontal segments to draw the sphere}

\item{hsegs}{Number of vertical segments to draw the sphere}

\item{phiStart}{Initial phi angle (azimuth)}

\item{phiLen}{Azimuth length (\code{2*pi} for a complete circumference)}

\item{thetaStart}{Initial theta angle (elevation)}

\item{initPoint}{Cylinder starting point}

\item{endPoint}{Cylinder end point}

\item{height}{Cylinder height}

\item{orientation}{Cylinder orientation}

\item{initRad}{Cylinder initial radius}

\item{endRad}{Cylinder end radius (will increase/decrease linearly)}

\item{rSegs}{Number of radial segments used to draw the cylinder section (circle)}

\item{hSegs}{Number of height segments used to draw the cylinder}

\item{openEnded}{If \code{TRUE} the cylinder is draw without ends (hollow)}

\item{nx}{Number of x-axis points to use to compute the parametric surface}

\item{ny}{Number of x-axis points to use to compute the parametric surface}

\item{inner}{Torus inner radius}

\item{outer}{Torus outer radius}

\item{thetaEnd}{Elevation length (\code{pi} for a complete circumference)}

\item{\dots}{Additional parameters for \code{\link{geoThreeJS}}.}

\item{function}{JS function \code{f(x,y} that defines the parametric surface}
}
\value{
A geoThreeJS object
}
\description{
A generic threeJS geometry definition. The geometry of an object defines its shape.
}
\details{
\code{meshGeometry} Creates a generic mesh object defined by a set of vertices and the face indexes.
The vertex color array could be also defined in the last column of the vertices matrix, but then face normals need to be computed.

\code{sphereGeometry} Creates a sphere geometry with a given radius among other parameters.
User can also give center position and rotation to apply

\code{cylinderGeometry} Creates a cylinder geometry with given radius, position and orientation among other options.

\code{parametricGeometry} Creates a parametric surface geometry from given JS function.
User can also set position, rotation, and scale.

\code{torusGeometry} Creates a torus geometry with given properties
}
\note{
If indexes in faces do not start at 0, they will be fixed.
}
\examples{
\dontrun{
   runShinyExample("mesh")
}

\dontrun{
   s <- sphereGeometry(1, position = c(1,1,1))
   runShinyExample("spheres")
}

\dontrun{
cyl <- cylinderGeometry(
 initPoint = c(0,0,0), height = 1, orientation = c(0,0,1),
 initRad = 1, endRad = 1)
 runShinyExample("cylinders")
}

\dontrun{
geos <- parametricGeometry(
htmlwidgets::JS(
"function(u,v){
           u -= 0.5;
           u *= 2;
           v *= (2 * 3.1415);
           return( new THREE.Vector3( u * Math.cos(v) , u * Math.sin(v) , u ) ); }"
 ),
 vertex.color.fun = htmlwidgets::JS("function(v,g,i,e,cs){ return(cs.getColor( v.z )) }")
 )
 runShinyExample("parametric")
}

\dontrun{
 torusGeometry(inner = 1, outer = 5, position = c(0,0,0), rotation = c(1,0,1))
 runShinyExample("torus")
}
}

